import streamlit as st
import paho.mqtt.client as mqtt
import pymongo
import json
import ssl
import queue
import pandas as pd
import datetime
import random
from streamlit_autorefresh import st_autorefresh
import logging
import sys

# --- Î°úÍ±∞ ÏÑ§Ï†ï ---
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
if not logger.handlers:
    handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# --- ÏïåÎ¶ºÏùå Ï¢ÖÎ•òÎ≥Ñ Base64 Îç∞Ïù¥ÌÑ∞ ---
FIRE_ALARM_SOUND_BASE64 = "data:audio/wav;base64,UklGRiSAAQBXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAAABkYXRhgQEAIAAAAAYWGRo3doN1l3p8gH+Cf4J/in+LgY2Pjp+RlpWXl5iYmJeXlpeXlpeXlpeXlpeXlpeXl5eXl5aXk5iUlpWXl5aXlpeVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVlJWVl-Q"
SAFETY_ALERT_SOUND_BASE64 = "data:audio/mpeg;base64,SUQzBAAAAAAAIVRYdEnDTPOq/3/3v/2/gAAAAAAAAAAAAAAB/2/g2/gAAA4SAAAEzGgAAAAAAD+kAzYAAAAAAAnnjk8eDEGANjBEyA/IjsgEyA7YEKkC5AlMBNkG/g2/gAAAAAAAAAAAAAAB/2/g2/gAAAA4SAAAEzGgAAAAAAD+kAzYAAAAAAAnnjk8eDEGANjBEyA/IjsgEyA7YEKkC5AlMBNk"

# --- ÏÑ§Ï†ï ---
HIVE_BROKER = st.secrets["HIVE_BROKER"]
HIVE_USERNAME = st.secrets["HIVE_USERNAME"]
HIVE_PASSWORD = st.secrets["HIVE_PASSWORD"]
MONGO_URI = st.secrets["MONGO_URI"]

HIVE_PORT = 8884
HIVE_TOPIC = "robot/alerts"
DB_NAME = "AlertDB"
COLLECTION_NAME = "AlertData"
CONNECTION_TIMEOUT_SECONDS = 30

# --- ÌéòÏù¥ÏßÄ ÏÑ§Ï†ï Î∞è Ï∫êÏãúÎêú Î¶¨ÏÜåÏä§ ---
st.set_page_config(page_title="ÏïàÏ†Ñ Î™®ÎãàÌÑ∞ÎßÅ ÎåÄÏãúÎ≥¥Îìú", layout="wide")

@st.cache_resource
def get_message_queue():
    return queue.Queue()

@st.cache_resource
def get_db_collection():
    try:
        logger.info("MongoDBÏóê Ïó∞Í≤∞ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§...")
        client = pymongo.MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        client.server_info()
        db = client[DB_NAME]
        logger.info(f"MongoDB Ïó∞Í≤∞ ÏÑ±Í≥µ. DB: '{DB_NAME}', Collection: '{COLLECTION_NAME}'")
        return db[COLLECTION_NAME]
    except Exception as e:
        st.error(f"MongoDB Ïó∞Í≤∞ Ïã§Ìå®: {e}")
        logger.error(f"MongoDB Ïó∞Í≤∞ Ïã§Ìå®: {e}")
        return None

@st.cache_resource
def start_mqtt_client(_message_queue):
    def on_connect(client, userdata, flags, rc, properties=None):
        if rc == 0:
            logger.info(f"MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ ÏÑ±Í≥µ. ÌÜ†ÌîΩ Íµ¨ÎèÖ: '{HIVE_TOPIC}'")
            client.subscribe(HIVE_TOPIC)
        else:
            logger.error(f"MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ Ïã§Ìå®, ÏΩîÎìú: {rc}")

    def on_message(client, userdata, msg):
        try:
            payload = msg.payload.decode()
            data = json.loads(payload)
            if all(key in data for key in ['type', 'message', 'timestamp']):
                _message_queue.put(data)
        except (json.JSONDecodeError, TypeError):
            pass

    client_id = f"streamlit-listener-{random.randint(0, 1000)}"
    client = mqtt.Client(client_id=client_id, transport="websockets", callback_api_version=mqtt.CallbackAPIVersion.VERSION2)
    client.username_pw_set(HIVE_USERNAME, HIVE_PASSWORD)
    client.tls_set(cert_reqs=ssl.CERT_NONE)
    client.on_connect = on_connect
    client.on_message = on_message
    try:
        client.connect(HIVE_BROKER, HIVE_PORT, 60)
        client.loop_start()
        return client
    except Exception as e:
        st.error(f"MQTT Ïó∞Í≤∞ Ïã§Ìå®: {e}")
        logger.error(f"MQTT Ïó∞Í≤∞ Ïã§Ìå®: {e}")
        return None

# --- ÏïåÎ¶ºÏùå Ïû¨ÏÉù Ìï®Ïàò ---
def play_notification_sound(sound_type="safety"):
    if sound_type == "fire":
        sound_data = FIRE_ALARM_SOUND_BASE64
    else:
        sound_data = SAFETY_ALERT_SOUND_BASE64
    audio_html = f'<audio autoplay><source src="{sound_data}" type="audio/mpeg"></audio>'
    st.html(audio_html)

# --- ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î∞è ÌÅê Ïã§Ìñâ/Ï¥àÍ∏∞Ìôî ---
message_queue = get_message_queue()
db_collection = get_db_collection()
mqtt_client = start_mqtt_client(message_queue)

# --- ÏÑ∏ÏÖò ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ---
if "latest_alerts" not in st.session_state:
    st.session_state.latest_alerts = []
if "current_status" not in st.session_state:
    st.session_state.current_status = {"message": "Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÎåÄÍ∏∞ Ï§ë...", "timestamp": "N/A"}
if "last_message_time" not in st.session_state:
    st.session_state.last_message_time = datetime.datetime.now()
# [ÌïµÏã¨ 1] ÏÜåÎ¶¨ ÌôúÏÑ±Ìôî ÏÉÅÌÉúÎ•º Ï†ÄÏû•Ìï† Î≥ÄÏàò Ï∂îÍ∞Ä
if "sound_enabled" not in st.session_state:
    st.session_state.sound_enabled = False

# --- ÏûêÎèô Ïû¨Ïó∞Í≤∞ Î°úÏßÅ ---
time_since_last_message = (datetime.datetime.now() - st.session_state.last_message_time).total_seconds()
if mqtt_client and time_since_last_message > CONNECTION_TIMEOUT_SECONDS:
    st.warning(f"{CONNECTION_TIMEOUT_SECONDS}Ï¥à Ïù¥ÏÉÅ Ïã†Ìò∏ ÏóÜÏùå. MQTT Ïû¨Ïó∞Í≤∞ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§...")
    logger.warning("MQTT Ïó∞Í≤∞ ÏãúÍ∞Ñ Ï¥àÍ≥º. Î™®Îì† Ï∫êÏãúÎ•º ÏßÄÏö∞Í≥† Ïû¨Ïó∞Í≤∞ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§.")
    st.cache_resource.clear()
    st.session_state.last_message_time = datetime.datetime.now()
    st.rerun()

# --- UI Ï†úÎ™© ---
st.title("üõ°Ô∏è Ìï≠ÎßåÏãúÏÑ§ ÌòÑÏû• ÏïàÏ†Ñ Î™®ÎãàÌÑ∞ÎßÅ")
logger.info("================ Ïä§Ìä∏Î¶ºÎ¶ø Ïï± UI Î†åÎçîÎßÅ ================")

# --- [ÌïµÏã¨ 2] ÏÇ¨Ïù¥ÎìúÎ∞îÏóê ÏÜåÎ¶¨ ÌôúÏÑ±Ìôî Î≤ÑÌäº Ï∂îÍ∞Ä ---
with st.sidebar:
    st.header("ÏÑ§Ï†ï")
    st.info("Î∏åÎùºÏö∞Ï†Ä Ï†ïÏ±ÖÏúºÎ°ú Ïù∏Ìï¥, ÏïåÎ¶ºÏùåÏùÑ Îì§ÏúºÏãúÎ†§Î©¥ Î®ºÏ†Ä ÏïÑÎûò Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÏÜåÎ¶¨Î•º ÌôúÏÑ±ÌôîÌï¥Ïïº Ìï©ÎãàÎã§.")
    if st.button("üîî ÏïåÎ¶ºÏùå ÌôúÏÑ±Ìôî", use_container_width=True):
        st.session_state.sound_enabled = True
        play_notification_sound() # Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú ÌÖåÏä§Ìä∏ ÏÜåÎ¶¨ Ïû¨ÏÉù
        st.toast("‚úÖ ÏïåÎ¶ºÏùåÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.")
    
    if st.session_state.sound_enabled:
        st.success("ÏïåÎ¶ºÏùå ÌôúÏÑ±Ìôî ÏÉÅÌÉú")
    else:
        st.warning("ÏïåÎ¶ºÏùå ÎπÑÌôúÏÑ±Ìôî ÏÉÅÌÉú")

# --- Î©îÏù∏ Î°úÏßÅ: ÌÅêÏóêÏÑú Î©îÏãúÏßÄ Ï≤òÎ¶¨ ---
if db_collection is not None:
    while not message_queue.empty():
        msg = message_queue.get()
        st.session_state.last_message_time = datetime.datetime.now()
        
        alert_type = msg.get("type")
        # [ÌïµÏã¨ 3] ÏÜåÎ¶¨Í∞Ä ÌôúÏÑ±ÌôîÎêú ÏÉÅÌÉúÏóêÏÑúÎßå ÏïåÎ¶ºÏùå Ïû¨ÏÉù
        if alert_type in ["fire", "safety"] and st.session_state.sound_enabled:
            play_notification_sound(alert_type)
        
        # ÌåùÏóÖÏùÄ ÏÜåÎ¶¨ ÌôúÏÑ±Ìôî Ïó¨Î∂ÄÏôÄ Í¥ÄÍ≥ÑÏóÜÏù¥ Ìï≠ÏÉÅ ÌëúÏãú
        if alert_type == "fire":
            st.toast(f"üî• Í∏¥Í∏â: ÌôîÏû¨ Í≤ΩÎ≥¥ Î∞úÏÉù!", icon="üî•")
        elif alert_type == "safety":
            st.toast(f"‚ö†Ô∏è Ï£ºÏùò: ÏïàÏ†ÑÏ°∞ÎÅº ÎØ∏Ï∞©Ïö© Í∞êÏßÄ!", icon="‚ö†Ô∏è")
        
        if alert_type == "normal":
            st.session_state.current_status = msg
            continue

        if 'source_ip' in msg:
            del msg['source_ip']

        try:
            msg['timestamp'] = datetime.datetime.strptime(msg['timestamp'], "%Y-%m-%d %H:%M:%S")
        except (ValueError, TypeError):
            msg['timestamp'] = datetime.datetime.now()

        st.session_state.latest_alerts.insert(0, msg)
        if len(st.session_state.latest_alerts) > 100:
            st.session_state.latest_alerts.pop()
        
        try:
            db_collection.insert_one(msg)
            logger.info("Î©îÏãúÏßÄÎ•º MongoDBÏóê ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÌñàÏäµÎãàÎã§.")
        except Exception as e:
            st.warning(f"DB Ï†ÄÏû• Ïã§Ìå®! ({e})")
            logger.error(f"MongoDB Ï†ÄÏû• Ïã§Ìå®: {e}")

# --- Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ---
if not st.session_state.latest_alerts and db_collection is not None:
    try:
        query = {"type": {"$ne": "normal"}}
        alerts = list(db_collection.find(query).sort("timestamp", pymongo.DESCENDING).limit(10))
        st.session_state.latest_alerts = alerts
    except Exception as e:
        st.error(f"Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: {e}")

# --- UI ÌëúÏãú ---
col1, col2 = st.columns([3, 1])
with col1:
    st.subheader("üì° ÏãúÏä§ÌÖú ÌòÑÏû¨ ÏÉÅÌÉú")
    status_message = st.session_state.current_status.get("message", "ÏÉÅÌÉú Ï†ïÎ≥¥ ÏóÜÏùå")
    status_time = st.session_state.current_status.get("timestamp", "N/A")
    st.info(f"{status_message} (ÎßàÏßÄÎßâ Ïã†Ìò∏: {status_time})")
with col2:
    st.subheader("MQTT Ïó∞Í≤∞ ÏÉÅÌÉú")
    if mqtt_client and mqtt_client.is_connected():
        st.success("üü¢ Ïã§ÏãúÍ∞Ñ ÏàòÏã† Ï§ë")
    else:
        st.error("üî¥ Ïó∞Í≤∞ ÎÅäÍπÄ")

st.divider()
st.subheader("üö® ÏµúÍ∑º Í≤ΩÎ≥¥ ÎÇ¥Ïó≠")

if not st.session_state.latest_alerts:
    st.info("ÏàòÏã†Îêú Í≤ΩÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.")
else:
    df = pd.DataFrame(st.session_state.latest_alerts)
    if 'timestamp' in df.columns:
        df['timestamp'] = pd.to_datetime(df['timestamp']).dt.tz_localize('UTC').dt.tz_convert('Asia/Seoul')
        display_df = df.rename(columns={"timestamp": "Î∞úÏÉù ÏãúÍ∞Å", "type": "Ïú†Ìòï", "message": "Î©îÏãúÏßÄ"})
        st.dataframe(
            display_df[['Î∞úÏÉù ÏãúÍ∞Å', 'Ïú†Ìòï', 'Î©îÏãúÏßÄ']].sort_values(by="Î∞úÏÉù ÏãúÍ∞Å", ascending=False),
            use_container_width=True,
            hide_index=True
        )

st_autorefresh(interval=2000, key="ui_refresher")

